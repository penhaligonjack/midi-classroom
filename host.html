<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Host — MIDI Classroom (Full Upgrade)</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial; padding:16px; max-width:1200px; margin:auto; }
  h1 { margin-bottom: 8px; }
  .controls { display:flex; gap:12px; flex-wrap:wrap; align-items:center; margin-bottom:12px; }
  select, button, input[type="range"] { padding:6px 8px; }
  #studentArea { display:flex; flex-direction:column; gap:12px; margin-top:16px; }
  .studentBox { border:1px solid #ddd; padding:10px; border-radius:8px; background:#fafafa; display:flex; gap:12px; align-items:flex-start; }
  .studentInfo { flex:1; }
  .studentHeader { display:flex; justify-content:space-between; align-items:center; gap:8px; margin-bottom:6px; }
  .meta { color:#666; font-size:13px; }
  .note { font-weight:700; }
  .miniPiano { width: 364px; height:56px; position:relative; }
  .whiteMini{ width:26px; height:56px; border:1px solid #333; background:#fff; float:left; box-sizing:border-box;}
  .whiteMini.active{ background:#a3d8ff; }
  .blackMini{ width:16px; height:34px; background:#111; position:absolute; top:0; margin-left:-8px; z-index:2; border-radius:0 0 3px 3px; }
  .blackMini.active{ background:#66aaff; }
  .flash { animation: flashbg 140ms linear; }
  @keyframes flashbg { from { background: #fff7e6 } to { background: #fafafa } }
  .studentControls { display:flex; flex-direction:column; gap:8px; align-items:flex-end; min-width:220px; }
  .small { font-size:13px; padding:6px 8px; }
  .downloadLink { display:inline-block; margin-top:6px; }
</style>

<!-- Lamejs for MP3 encoding -->
<script src="https://unpkg.com/lamejs@1.2.0/lame.min.js"></script>
</head>
<body>
  <h1>Host — MIDI Classroom (Full)</h1>

  <div class="controls">
    <label>Classroom:
      <select id="classroomSelect"><option value="77">77</option><option value="78">78</option></select>
    </label>

    <label>Monitor Mode:
      <select id="monitorMode">
        <option value="CLASS">Classroom (all)</option>
        <option value="SOLO">Solo keyboard</option>
      </select>
    </label>

    <label>Solo Keyboard:
      <select id="soloKeyboard"><option value="">(choose)</option></select>
    </label>

    <label>Volume: <span id="volLabel">85</span>%</label>
    <input id="volume" type="range" min="0" max="100" value="85" style="width:180px">

    <button id="connectBtn">Start Hosting</button>

    <span id="status" class="meta">Not connected</span>
  </div>

  <div id="studentArea"></div>

<script>
/* ====================== Configuration ====================== */
function wsUrl(){
  if (location.hostname === "localhost" || location.protocol === "file:") return "ws://localhost:3000";
  return `wss://${window.location.host}`;
}

/* ====================== UI references ====================== */
const classroomSelect = document.getElementById('classroomSelect');
const monitorMode = document.getElementById('monitorMode');
const soloKeyboard = document.getElementById('soloKeyboard');
const volume = document.getElementById('volume');
const volLabel = document.getElementById('volLabel');
const connectBtn = document.getElementById('connectBtn');
const statusEl = document.getElementById('status');
const studentArea = document.getElementById('studentArea');

/* fill soloKeyboard 1..15 */
for (let i=1;i<=15;i++){ const o=document.createElement('option'); o.value=i; o.textContent=i; soloKeyboard.appendChild(o); }

/* ====================== Audio setup ====================== */
let audioCtx = null;
let masterGain = null;
let recordGain = null; // tap used for recording and routing

function initAudio(){
  if (audioCtx) return;
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  // master chain: voices -> recordGain -> masterGain -> destination
  masterGain = audioCtx.createGain();
  masterGain.gain.value = Number(volume.value)/100;
  masterGain.connect(audioCtx.destination);

  recordGain = audioCtx.createGain();
  recordGain.gain.value = 1;
  // recordGain feeds masterGain (so recording captures what goes to master)
  recordGain.connect(masterGain);
}

volume.addEventListener('input', () => {
  volLabel.textContent = volume.value;
  if (masterGain && audioCtx) masterGain.gain.setValueAtTime(Number(volume.value)/100, audioCtx.currentTime || 0);
});

/* ====================== Student storage & UI ====================== */
/* students keyed by `${classroom}-${keyboard}` */
const students = new Map();

function studentKey(classroom, keyboard){ return `${classroom}-${keyboard}`; }

/* create student object and UI, returns student object */
function ensureStudent(classroom, keyboard){
  const key = studentKey(classroom, keyboard);
  if (students.has(key)) return students.get(key);

  initAudio();

  // DOM
  const box = document.createElement('div');
  box.className = 'studentBox';
  box.id = 'box_' + key;

  box.innerHTML = `
    <div class="studentInfo">
      <div class="studentHeader">
        <div>
          <strong>Keyboard ${keyboard}</strong>
          <div class="meta">Class ${classroom}</div>
        </div>
        <div>Last note: <span id="note_${key}" class="note">(none)</span></div>
      </div>
      <div class="miniPiano" id="mini_${key}"></div>
    </div>
    <div class="studentControls">
      <div>
        <button class="small startRec" data-key="${key}">Start Recording</button>
        <button class="small stopRec" data-key="${key}" disabled>Stop & Download MP3</button>
      </div>
      <div>
        <label class="meta">Mute<input type="checkbox" class="muteBox" data-key="${key}" /></label>
      </div>
      <div id="recStatus_${key}" class="meta"></div>
    </div>
  `;

  // create per-student audio nodes
  const mediaDest = audioCtx.createMediaStreamDestination();
  const outGain = audioCtx.createGain(); // routes to recordGain -> masterGain
  outGain.gain.value = 0; // default to muted until monitoring mode sets it
  outGain.connect(recordGain);

  const st = {
    classroom: String(classroom),
    keyboard: String(keyboard),
    key,
    boxEl: box,
    noteEl: box.querySelector('#note_' + key),
    miniEl: box.querySelector('#mini_' + key),
    mediaDest, outGain,
    mediaRecorder: null, recordedChunks: [], isRecording:false,
    voices: new Map() // note string -> voice object
  };

  // create mini piano
  buildMiniPiano(st.miniEl);

  // attach buttons
  const startBtn = box.querySelector('.startRec');
  const stopBtn  = box.querySelector('.stopRec');
  const recStatus = box.querySelector('#recStatus_' + key);
  startBtn.addEventListener('click', () => startRecordingStudent(st, startBtn, stopBtn, recStatus));
  stopBtn.addEventListener('click', () => stopRecordingStudent(st, startBtn, stopBtn, recStatus));

  // mute checkbox
  const muteBox = box.querySelector('.muteBox');
  muteBox.addEventListener('change', (e) => {
    if (e.target.checked) st.outGain.gain.setValueAtTime(0, audioCtx.currentTime || 0);
    else updateMonitoringRouting(); // restore based on monitoring mode
  });

  students.set(key, st);

  // only append to DOM if this student's classroom matches selected classroom
  if (classroomSelect.value === String(classroom)) studentArea.appendChild(box);

  return st;
}

/* remove boxes that are not in selected classroom */
function showStudentsForClassroom(classroom){
  studentArea.innerHTML = '';
  for (const [k, st] of students.entries()){
    if (st.classroom === String(classroom)) studentArea.appendChild(st.boxEl);
  }
}

/* ====================== Mini piano (C4..C5) ====================== */
function buildMiniPiano(container){
  container.innerHTML = '';
  const start = 60, end = 72; // C4..C5
  const whiteSteps = [0,2,4,5,7,9,11];
  let whiteIndex = 0;
  for (let n = start; n <= end; n++){
    const isWhite = whiteSteps.includes(n % 12);
    if (isWhite){
      const w = document.createElement('div'); w.className='whiteMini'; w.dataset.note=n;
      w.style.float='left';
      container.appendChild(w);
      whiteIndex++;
    } else {
      const b = document.createElement('div'); b.className='blackMini'; b.dataset.note=n;
      b.style.left = ((whiteIndex-1)*26 + 18) + 'px';
      container.appendChild(b);
    }
  }
}
function highlightMini(key, note, on){
  const st = students.get(key);
  if (!st) return;
  const el = Array.from(st.miniEl.querySelectorAll('[data-note]')).find(e => Number(e.dataset.note) === Number(note));
  if (!el) return;
  if (on) el.classList.add('active'); else el.classList.remove('active');
}

/* ====================== Voice engine (per-student) ====================== */
/* startVoiceForStudent: create oscillators, filter, envelope
   connect to st.outGain (which then connects to recordGain->masterGain).
   Also connect a recGain to st.mediaDest so recording captures the student's audio.
*/
function startVoiceForStudent(st, note, vel){
  const key = String(note);
  if (st.voices.has(key)) return; // already playing
  const now = audioCtx.currentTime;
  const freq = 440 * Math.pow(2, (Number(note) - 69)/12);

  const osc1 = audioCtx.createOscillator(); osc1.type='triangle'; osc1.frequency.setValueAtTime(freq, now);
  const osc2 = audioCtx.createOscillator(); osc2.type='sawtooth'; osc2.frequency.setValueAtTime(freq*2.0, now);

  const filter = audioCtx.createBiquadFilter(); filter.type='lowpass'; filter.frequency.setValueAtTime(800 + (vel/127)*3000, now);
  const gainNode = audioCtx.createGain();
  const peak = 0.22 * (vel/127);
  gainNode.gain.setValueAtTime(0, now);
  gainNode.gain.linearRampToValueAtTime(peak, now + 0.005);
  gainNode.gain.linearRampToValueAtTime(peak * 0.6, now + 0.12);

  osc1.connect(filter); osc2.connect(filter); filter.connect(gainNode);

  // route to outGain (audible when monitoring) and to recorder destination
  gainNode.connect(st.outGain);
  const recGain = audioCtx.createGain(); recGain.gain.value = 1;
  gainNode.connect(recGain);
  recGain.connect(st.mediaDest);

  osc1.start(now); osc2.start(now);

  st.voices.set(key, {osc1, osc2, filter, gainNode, recGain});
}

function stopVoiceForStudent(st, note){
  const key = String(note);
  const v = st.voices.get(key);
  if (!v) return;
  const now = audioCtx.currentTime;
  v.gainNode.gain.cancelScheduledValues(now);
  v.gainNode.gain.setTargetAtTime(0.0001, now, 1.1);
  try { v.osc1.stop(now + 1.5); v.osc2.stop(now + 1.5); } catch(e){}
  setTimeout(()=> st.voices.delete(key), 1700);
}

/* ====================== Recording (per-student) ====================== */
function startRecordingStudent(st, startBtn, stopBtn, recStatusEl){
  if (st.isRecording) return;
  st.recordedChunks = [];
  const mimeType = MediaRecorder.isTypeSupported('audio/webm;codecs=opus') ? 'audio/webm;codecs=opus' : (MediaRecorder.isTypeSupported('audio/ogg;codecs=opus') ? 'audio/ogg;codecs=opus' : 'audio/webm');
  try {
    st.mediaRecorder = new MediaRecorder(st.mediaDest.stream, { mimeType });
  } catch(e){
    alert('Recording not supported in this browser.');
    return;
  }
  st.mediaRecorder.ondataavailable = ev => { if (ev.data && ev.data.size>0) st.recordedChunks.push(ev.data); };
  st.mediaRecorder.onstop = async () => {
    recStatusEl.textContent = 'Encoding MP3...';
    try {
      const blob = new Blob(st.recordedChunks, { type: st.mediaRecorder.mimeType });
      const mp3 = await convertBlobToMp3(blob);
      const url = URL.createObjectURL(mp3);
      const a = document.createElement('a'); a.href = url; a.download = `student-${st.classroom}-${st.keyboard}-${Date.now()}.mp3`; a.textContent = 'Download MP3'; a.className='downloadLink';
      // remove old download link if exists
      const prev = st.boxEl.querySelector('.downloadLink'); if (prev) prev.remove();
      st.boxEl.appendChild(a);
      recStatusEl.textContent = 'Ready';
    } catch(e){ console.error(e); recStatusEl.textContent = 'Encode failed'; }
  };
  st.mediaRecorder.start(200);
  st.isRecording = true; startBtn.disabled = true; stopBtn.disabled = false; recStatusEl.textContent = 'Recording...';
}
function stopRecordingStudent(st, startBtn, stopBtn, recStatusEl){
  if (!st.isRecording || !st.mediaRecorder) return;
  st.mediaRecorder.stop();
  st.isRecording = false; startBtn.disabled = false; stopBtn.disabled = true; recStatusEl.textContent = 'Stopping...';
}

/* convert blob to mp3 via decode + OfflineAudioContext + lamejs */
async function convertBlobToMp3(blob){
  const arrayBuffer = await blob.arrayBuffer();
  if (!audioCtx) initAudio();
  const decoded = await audioCtx.decodeAudioData(arrayBuffer.slice(0));
  const sampleRate = 44100;
  const offline = new OfflineAudioContext(1, Math.ceil(decoded.duration*sampleRate), sampleRate);
  const src = offline.createBufferSource();
  // downmix to mono
  const ch = decoded.numberOfChannels;
  const len = decoded.length;
  const mix = new Float32Array(len);
  for (let c=0;c<ch;c++){
    const d = decoded.getChannelData(c);
    for (let i=0;i<len;i++) mix[i] = (mix[i] || 0) + d[i] / ch;
  }
  const buf = offline.createBuffer(1, mix.length, decoded.sampleRate);
  buf.copyToChannel(mix, 0);
  src.buffer = buf; src.connect(offline.destination); src.start(0);
  const rendered = await offline.startRendering();
  const channelData = rendered.getChannelData(0);
  const int16 = floatTo16BitPCM(channelData);
  return encodeMp3(int16, sampleRate);
}
function floatTo16BitPCM(float32Array){
  const l = float32Array.length; const out = new Int16Array(l);
  for (let i=0;i<l;i++){ let s = Math.max(-1, Math.min(1, float32Array[i])); out[i] = s < 0 ? s * 0x8000 : s * 0x7FFF; }
  return out;
}
function encodeMp3(samplesInt16, sampleRate){
  const mp3enc = new lamejs.Mp3Encoder(1, sampleRate, 128);
  const blockSize = 1152;
  const mp3Data = [];
  for (let i=0;i<samplesInt16.length;i+=blockSize){
    const chunk = samplesInt16.subarray(i, i+blockSize);
    const mp3buf = mp3enc.encodeBuffer(chunk);
    if (mp3buf.length > 0) mp3Data.push(new Uint8Array(mp3buf));
  }
  const tail = mp3enc.flush();
  if (tail.length>0) mp3Data.push(new Uint8Array(tail));
  return new Blob(mp3Data, { type: 'audio/mp3' });
}

/* ====================== WebSocket handling ====================== */
let ws = null;

connectBtn.addEventListener('click', () => {
  const classroom = String(classroomSelect.value);
  setStatus('Connecting to ' + wsUrl());
  ws = new WebSocket(wsUrl());

  ws.onopen = () => {
    setStatus('Connected as host (class ' + classroom + ')');
    // notify server (if server expects host-join)
    ws.send(JSON.stringify({ type: 'host-join', classroom }));
    initAudio();
    showStudentsForClassroom(classroom);
  };

  ws.onmessage = (ev) => {
    let msg;
    try { msg = JSON.parse(ev.data); } catch(e){ console.warn('Bad message', ev.data); return; }

    // handle join events
    if (msg.type === 'student-join' || msg.type === 'joined') {
      const classr = String(msg.classroom ?? msg.room ?? msg.roomId ?? msg.class);
      const keyboard = String(msg.keyboard ?? msg.k ?? msg.id ?? msg.key);
      if (!classr || !keyboard) return;
      ensureStudent(classr, keyboard);
      if (classr === String(classroomSelect.value)) showStudentsForClassroom(classroomSelect.value);
      return;
    }

    // handle incoming midi events (various shapes)
    if (msg.type === 'student-midi' || msg.type === 'midi') {
      const classr = String(msg.classroom ?? msg.room ?? msg.classroom ?? msg.class);
      const keyboard = String(msg.keyboard ?? msg.k ?? msg.from ?? msg.key ?? msg.id);
      // normalize note & vel
      let cmd, note, vel;
      if (Array.isArray(msg.midi)) { cmd = msg.midi[0]; note = msg.midi[1]; vel = msg.midi[2]; }
      else if (typeof msg.note !== 'undefined') { cmd = 144; note = msg.note; vel = msg.velocity ?? msg.vel ?? 127; }
      else { return; }

      // filter by selected classroom
      if (classr !== String(classroomSelect.value)) return;

      // ensure student object exists
      const st = ensureStudent(classr, keyboard);

      // update UI
      st.noteEl.textContent = midiToName(Number(note));
      st.boxEl.classList.add('flash'); setTimeout(()=> st.boxEl.classList.remove('flash'), 120);
      highlightMini(st.key, Number(note), true);
      setTimeout(()=> highlightMini(st.key, Number(note), false), 180);

      // decide monitoring routing
      const mode = monitorMode.value;
      const solo = String(soloKeyboard.value);
      const monitorAll = (mode === 'CLASS');
      const monitorSolo = (mode === 'SOLO' && solo !== '');

      // only route outGain audible when (monitorAll) OR (monitorSolo && keyboard matches) AND NOT muted checkbox
      const shouldPlay = (monitorAll || (monitorSolo && solo === keyboard)) && !st.boxEl.querySelector('.muteBox').checked;
      st.outGain.gain.setValueAtTime(shouldPlay ? 1.0 : 0.0, audioCtx.currentTime || 0);

      // handle note on/off
      const status = (Number(cmd) & 0xf0);
      if ((status === 0x90 && Number(vel) > 0)) {
        startVoiceForStudent(st, Number(note), Number(vel));
      } else if (status === 0x80 || (status === 0x90 && Number(vel) === 0)) {
        stopVoiceForStudent(st, Number(note));
      }
    }
  };

  ws.onclose = () => setStatus('Disconnected');
  ws.onerror = (e) => { setStatus('WebSocket error'); console.error(e); };
});

/* ====================== Helpers ====================== */
function setStatus(s){ statusEl.textContent = s; }
function midiToName(n){
  const names = ["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"];
  return names[n % 12] + (Math.floor(n / 12) - 1);
}

/* refresh visible students for classroom */
function showStudentsForClassroom(classroom){
  studentArea.innerHTML = '';
  for (const [k, st] of students.entries()){
    if (st.classroom === String(classroom)) studentArea.appendChild(st.boxEl);
  }
}

/* update routing when monitor options change */
monitorMode.addEventListener('change', updateMonitoringRouting);
soloKeyboard.addEventListener('change', updateMonitoringRouting);
classroomSelect.addEventListener('change', () => { showStudentsForClassroom(classroomSelect.value); });

function updateMonitoringRouting(){
  const mode = monitorMode.value;
  const solo = String(soloKeyboard.value);
  for (const [k, st] of students.entries()){
    // muted checkbox has priority; if muted, keep outGain 0
    const muted = st.boxEl.querySelector('.muteBox').checked;
    const shouldPlay = (mode === 'CLASS') || (mode === 'SOLO' && String(st.keyboard) === solo);
    st.outGain.gain.setValueAtTime((shouldPlay && !muted) ? 1.0 : 0.0, audioCtx.currentTime || 0);
  }
}

/* ====================== End ====================== */
</script>
</body>
</html>
